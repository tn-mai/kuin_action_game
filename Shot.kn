{
  ショット
}

class ShotList()
  var shotList : list<Actor@Actor>

  { 初期化 }
  func Initialize()
    do this.shotList :: #list<Actor@Actor>
  end func

  { ショット発生 }
  func Add(position : Main@Position, velocity : Main@Vector2)
    var actor : Actor@Actor :: Actor@Create(position, Main@MakeRect(-16.0, -8.0, 16.0, 8.0))
    do actor.velocity :: ##velocity
    do this.shotList.Add(actor)
  end func

  { ショット移動 }
  func Action(resource : Main@Resource)
    do this.shotList.Head()
    while (!this.shotList.ChkEnd())
      var shot : Actor@Actor :: this.shotList.Get()
      var result : Map@CollisionResult :: Map@Collision(shot)
      if (result.isHitX | result.isHitY)
        do this.shotList.Del()
      elif (shot.position.x < -16.0 | shot.position.x > Map@width $ float * Map@blockW)
        do this.shotList.Del()
      else
        do this.shotList.Next()
      end if
    end while
  end func

  { 描画 }
  func Draw(camera : Main@Position)
    do this.shotList.Head()
    while (!this.shotList.ChkEnd())
      var shot : Actor@Actor :: this.shotList.Get()
      var x : float :: shot.position.x - 16.0 - camera.x
      var y : float :: shot.position.y - 8.0 - camera.y
      do Draw@Rect(x, y, 32.0, 16.0, 1.0, 0.0, 1.0, 1.0)
      do this.shotList.Next()
    end while
  end func
end class

{ 弾リストを作成する }
func Create() : @ShotList
  var shotList : @ShotList :: #@ShotList
  do shotList.Initialize()
  return shotList
end func

func HasCollision(a0 : float, a1 : float, b0 : float, b1 : float) : bool
  { a0 b0 a1 }
  if (a0 < b0 & a1 >= b0)
    return true
  { a0 b1 a1 }
  elif (a0 < b1 & a1 >= b1)
    return true
  else
    return false
  end if
end func

{
  削除する弾の選択
  Collision()の衝突発生時コールバックの戻り値.
  衝突によって削除される要素を選択.
}
enum DeletionRequest
  None { どちらも削除しない. }
  Left { 左側要素のみ削除. }
  Right { 右側要素のみ削除. }
  Both { 両方の要素を削除. }
end enum

{ 弾同士の当たり判定 }
func Collision(lhs : @ShotList, rhs : @ShotList, f : func<(Actor@Actor, Actor@Actor) : @DeletionRequest>)
  do lhs.shotList.Head()
  while l(!lhs.shotList.ChkEnd())
    var left : Actor@Actor :: lhs.shotList.Get()
    var rectL : Main@Rect :: (##left.rect).AddPosition(left.position)
    do rhs.shotList.Head()
    while r(!rhs.shotList.ChkEnd())
      var right : Actor@Actor :: rhs.shotList.Get()
      var rectR : Main@Rect :: (##right.rect).AddPosition(right.position)
      if (!@HasCollision(rectL.left, rectL.right, rectR.left, rectR.right))
        do rhs.shotList.Next()
        continue r
      elif (!@HasCollision(rectL.top, rectL.bottom, rectR.top, rectR.bottom))
        do rhs.shotList.Next()
        continue r
      end if
      switch (f(left, right))
      case (@DeletionRequest#None)
        do rhs.shotList.Next()
      case (@DeletionRequest#Left)
        do lhs.shotList.Del()
        continue l
      case (@DeletionRequest#Right)
        do rhs.shotList.Del()
        continue r
      case (@DeletionRequest#Both)
        do lhs.shotList.Del()
        do rhs.shotList.Del()
        continue l
      end switch
    end while
    do lhs.shotList.Next()
  end while
end func
