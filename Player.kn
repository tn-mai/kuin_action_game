{
  プレイヤー
}

const width : float :: 100.0
const height : float :: 160.0
const renderOffsetX : float :: -(@width / 2.0)
const renderOffsetY : float :: -@height

{ 範囲補正 }
func Correct(n : &float, min : float, max : float) : bool
  if (n < min)
    do n :: min
    return true
  elif (n > max)
    do n :: max - 1.0
    return true
  end if
  return false
end func

func CorrectInt(n : &int, min : int, max : int) : bool
  if (n < min)
    do n :: min
    return true
  elif (n >= max)
    do n :: max - 1
    return true
  end if
  return false
end func

{ 初期化 }
func Create(x : float, y : float) : Actor@Actor
  return Actor@Create(Main@MakePosition(x, y), Main@MakeRect(-(@width * 0.8 / 2.0), -(@height * 0.9), @width * 0.8 / 2.0, 0.0))
end func

{ 操作 }
func Action(actor : Actor@Actor)
  { 左右移動 }
  const runVelocity : float :: 16.0
  if (Input@Pad(0, Input@EBtn#Left) > 0)
    do actor.position.x :- runVelocity
    var x : int :: actor.GetHitLeft(Map@width, Map@blockW)
    var range : Main@RangeInt :: Main@MakeRangeInt(actor.GetHitTop(Map@height, Map@blockH, 60.0), actor.GetHitBottom(Map@height, Map@blockH, -10.0))
    for y(range.first, range.last)
      if (Map@data[y][x] = 'X')
        do actor.position.x :: (x + 1) $ float * Map@blockW - actor.rect.left
        break y
      end if
    end for
  end if
  if (Input@Pad(0, Input@EBtn#Right) > 0)
    do actor.position.x :+ runVelocity
    var x : int :: actor.GetHitRight(Map@width, Map@blockW)
    var range : Main@RangeInt :: Main@MakeRangeInt(actor.GetHitTop(Map@height, Map@blockH, 60.0), actor.GetHitBottom(Map@height, Map@blockH, -10.0))
    try
    for y(range.first, range.last)
      if (Map@data[y][x] = 'X')
        do actor.position.x :: x $ float * Map@blockW - actor.rect.right - 1.0
        break y
      end if
    end for
    catch()
      do Dbg@Log("x:" ~ x.ToStr() ~ " range:" ~ range.ToStr())
    end try
  end if
  const leftLimit : float :: @width / 2.0
  const rightLimit : float :: Map@width $ float * Map@blockW - @width / 2.0
  do @Correct(&actor.position.x, leftLimit, rightLimit)

  { ジャンプ }
  var jumpPower : float :: -15.0 * Lib@Sqrt(2.0 * Main@gravity)
  if (Input@Pad(0, Input@EBtn#B) = 1)
    do actor.velocity.y :: jumpPower
  end if
  do actor.position.y :+ actor.velocity.y
  const topLimit : float :: -@height
  const bottomLimit : float :: Map@height $ float * Map@blockH + @height - 10.0

  { 重力制御 }
  if (@Correct(&actor.position.y, topLimit, bottomLimit))
    do actor.velocity.y  :: 0.0
  else
    do actor.velocity.y  :+ Main@gravity
  end if

  do @CorrectForMap(actor)
end func

{ 背景当たり判定 }
func CorrectForMap(actor : Actor@Actor)
  var range : Main@RangeInt :: Main@MakeRangeInt(actor.GetHitLeft(Map@width, Map@blockW), actor.GetHitRight(Map@width, Map@blockW))
  if (actor.velocity.y < 0.0)
    var y : int :: actor.GetHitTop(Map@height, Map@blockH, 0.0)
    try
    for x(range.first, range.last)
      if (Map@data[y][x] = 'X')
        do actor.position.y :: (y + 1) $ float * Map@blockH + @height
        do actor.velocity.y :: 0.0
        break x
      end if
    end for
    catch()
      do Dbg@Log("up error:" ~ range.ToStr())
    end try
  end if
  if (actor.velocity.y >= 0.0)
    var y : int :: actor.GetHitBottom(Map@height, Map@blockH, 0.0)
    try
    for x(range.first, range.last)
      if (Map@data[y][x] = 'X')
        do actor.position.y :: y $ float * Map@blockH
        do actor.velocity.y :: 0.0
        break x
      end if
    end for
    catch()
      do Dbg@Log("down error:" ~ range.ToStr())
    end try
  end if
end func

{ 描画 }
func Draw(actor : Actor@Actor, camera : Main@Position)
  var x : float :: actor.position.x + @renderOffsetX - camera.x
  var y : float :: actor.position.y + @renderOffsetY - camera.y
  do Draw@Rect(x, y, @width, @height, 1.0, 0.0, 0.0, 1.0)
end func
