{
  プレイヤー
}

const width : float :: 100.0
const height : float :: 160.0
const renderOffsetX : float :: -(@width / 2.0)
const renderOffsetY : float :: -@height

{ 範囲補正 }
func Correct(n : &float, min : float, max : float) : bool
  if (n < min)
    do n :: min
    return true
  elif (n > max)
    do n :: max - 1.0
    return true
  end if
  return false
end func

{ 初期化 }
func Create(x : float, y : float) : Actor@Actor
  return Actor@Create(Main@MakePosition(x, y), Main@MakeRect(-(@width * 0.8 / 2.0), -(@height * 0.9), @width * 0.8 / 2.0, 0.0))
end func

{ 操作 }
func Action(resource : Main@Resource, actor : Actor@Actor)
  { 左右移動 }
  const runVelocity : float :: 6.0
  const maxRunVelocity : float :: 16.0
  var velocity : Main@Vector2 :: ##actor.velocity
  if (Input@Pad(0, Input@EBtn#Left) > 0)
    do velocity.x :- runVelocity
    if (velocity.x < -maxRunVelocity)
      do velocity.x :: -maxRunVelocity
    end if
  elif (Input@Pad(0, Input@EBtn#Right) > 0)
    do velocity.x :+ runVelocity
    if (velocity.x > maxRunVelocity)
      do velocity.x :: maxRunVelocity
    end if
  else
    if (velocity.x > 0.0)
      do velocity.x :- runVelocity
      if (velocity.x < 0.0)
        do velocity.x :: 0.0
      end if
    elif (velocity.x < 0.0)
      do velocity.x :+ runVelocity
      if (velocity.x < 0.0)
        do velocity.x :: 0.0
      end if
    end if
  end if

  { ジャンプ }
  if (Input@Pad(0, Input@EBtn#B) = 1)
    var jumpPower : float :: -15.0 * Lib@Sqrt(2.0 * Main@gravity)
    do velocity.y :: jumpPower
  end if

  { ショット }
  if (Input@Pad(0, Input@EBtn#C) = 1)
    var pos : Main@Position :: ##actor.position
    do pos.y :+ (actor.rect.top + actor.rect.bottom) / 2.0
    do PlayerShot@Add(pos, Main@MakeVector2(32.0, 0.0))
    do Dbg@Log("shot")
  end if
  { 重力制御 }
  do velocity.y  :+ Main@gravity
  const topLimit : float :: -@height
  const bottomLimit : float :: Map@height $ float * Map@blockH + @height - 10.0
  if (@Correct(&actor.position.y, topLimit, bottomLimit))
    do actor.velocity.y  :: 0.0
  end if

  do actor.velocity :: velocity

  var result : Map@CollisionResult :: Map@Collision(actor)
  do Main@DrawText(resource, "x:" ~ result.isHitX.ToStr(), 32, 0, 0)
  do Main@DrawText(resource, "y:" ~ result.isHitY.ToStr(), 32, 300, 0)
  do Main@DrawText(resource, actor.velocity.ToStr(), 32, 0, 100)

  const leftLimit : float :: @width / 2.0
  const rightLimit : float :: Map@width $ float * Map@blockW - @width / 2.0
  do @Correct(&actor.position.x, leftLimit, rightLimit)
end func

{ 描画 }
func Draw(actor : Actor@Actor, camera : Main@Position)
  var x : float :: actor.position.x + @renderOffsetX - camera.x
  var y : float :: actor.position.y + @renderOffsetY - camera.y
  do Draw@Rect(x, y, @width, @height, 1.0, 0.0, 0.0, 1.0)
end func
