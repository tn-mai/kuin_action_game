{
  敵
}

const width : float :: 100.0
const height : float :: 160.0

const shotSpeed : float :: 16.0

const shotIntervalMin : int :: 20
const shotIntervalMax : int :: 100
const shotRange : float :: 800.0

{ 次弾を投げる間隔を取得する }
func GetShotInterval() : int
  return Rnd@Get(@shotIntervalMin, @shotIntervalMax)
end func

{ 敵クラス }
class Enemy(Actor@Actor)
  enum State
    Entry
    Active
    Dead
  end enum

  var shotInterval : int
  var state : State
  var stateCount : int
  var animation : AnimationData@Animation

  func Damaged()
    if (this.state <> State#Dead)
      do this.collisionMask :: this.collisionMask.And(CollisionGroup@maskEnemy.Not())
      do this.state :: State#Dead
      do this.stateCount :: 60
      do this.animation.Set((this.direction.x >= 0.0 ?(AnimationData@Action#EnemyHitR, AnimationData@Action#EnemyHitL)) $ int)
      do this.velocity.x :: this.direction.x * -1.0
      do SE@Play(Main@SEID#Dead $ int)
    end if
  end func
end class

{ 出現敵リスト }
class EnemyList()
  var enemyList : Actor@List
  var animationData : AnimationData@Data
  var texture : Draw@CTex

  { 初期化 }
  func Initialize()
    do this.enemyList :: #Actor@List
    try
    do this.animationData :: AnimationData@Load("enemy.knanm")
    do this.texture :: Draw@LoadTex(this.animationData.textureName)
    catch()
      do Dbg@Log("ERROR: Can't load enemy data")
    end try
  end func

  { 現在の出現数 }
  func Len() : int
    return this.enemyList.Len()
  end func

  { 敵出現 }
  func Add(position : Main@Position)
    var enemy : @Enemy :: #@Enemy
    var rect : Main@Rect :: Main@MakeRect(-(@width * 0.8 / 2.0), -(@height * 0.9), @width * 0.8 / 2.0, 0.0)
    do (enemy $ Actor@Actor).Initialize(position, rect)
    do enemy.shotInterval :: @shotIntervalMax
    do enemy.state :: @Enemy#State#Entry
    do enemy.stateCount :: 30
    do enemy.animation :: AnimationData@MakeAnimation(this.animationData, this.texture, AnimationData@Action#EnemyL $ int)
    do enemy.direction.Set(-1.0, 0.0)
    do Main@SetColorRGBA(&enemy.color, 0.0, 1.0, 0.0, 1.0)
    do enemy.category :: CollisionGroup@categoryEnemy
    do enemy.collisionMask :: CollisionGroup@maskEnemy.And(CollisionGroup@categoryPlayer.Not())
    do this.enemyList.Add(enemy)
  end func

  { 敵リスト更新 }
  func Action(resource : Main@Resource, player : Actor@Actor, shotList : Shot@ShotList)
    do this.enemyList.Head()
    while loop(!this.enemyList.ChkEnd())
      var enemy : @Enemy :: this.enemyList.Get() $ @Enemy
      do enemy.velocity.y  :+ Main@gravity
      var result : Map@CollisionResult :: Map@Collision(enemy)
      switch (enemy.state)
      case (@Enemy#State#Entry)
        do enemy.stateCount :- 1
        if (enemy.stateCount < 0)
          do enemy.state :: @Enemy#State#Active
          do enemy.collisionMask :: enemy.collisionMask.Or(CollisionGroup@categoryPlayer)
        end if
      case (@Enemy#State#Active)
        { 特別な処理はない }
      case (@Enemy#State#Dead)
        do enemy.stateCount :- 1
        if (enemy.stateCount < 0)
          do this.enemyList.Del()
        else
          do this.enemyList.Next()
        end if
        continue loop
      end switch

      var animationIndex : int :: enemy.animation.index
      if (enemy.shotInterval > 0)
        do enemy.shotInterval :- 1
      else
        var distanceX : float :: player.position.x - enemy.position.x
        var distanceY : float :: player.position.y - enemy.position.y
        if (Lib@Hypot(distanceX, distanceY) < @shotRange)
          { kuinのラジアン 左=0.0 下=0.5pi 右 1.0pi 上 1.5pi }
          var direction : float :: Lib@InvRot(distanceX, distanceY)
          var pos : Main@Position :: ##enemy.position
          do pos.y :- (enemy.rect.bottom - enemy.rect.top) * 0.75
          if (direction <= 0.25 * Lib@Pi | direction >= 1.75 * Lib@Pi)
            do enemy.direction.Set(1.0, 0.0)
            do animationIndex :: AnimationData@Action#EnemyR $ int
            do shotList.Add(pos, (##enemy.direction).MulScalar(@shotSpeed), CollisionGroup@categoryEnemyShot, CollisionGroup@maskEnemyShot, AnimationData@Action#EnemyShot $ int)
            do SE@Play(Main@SEID#EnemyShot $ int)
          elif (direction >= 0.75 * Lib@Pi & direction <= 1.25 * Lib@Pi)
            do enemy.direction.Set(-1.0, 0.0)
            do animationIndex :: AnimationData@Action#EnemyL $ int
            do shotList.Add(pos, (##enemy.direction).MulScalar(@shotSpeed), CollisionGroup@categoryEnemyShot, CollisionGroup@maskEnemyShot, AnimationData@Action#EnemyShot $ int)
            do SE@Play(Main@SEID#EnemyShot $ int)
          end if
        end if
        do enemy.shotInterval :: @GetShotInterval()
      end if
      if (animationIndex <> enemy.animation.index)
        do enemy.animation.Set(animationIndex)
      else
        do enemy.animation.Update()
      end if
      do this.enemyList.Next()
    end while
  end func

  { 敵リスト描画 }
  func Draw(camera : Main@Position)
    do this.enemyList.Head()
    while (!this.enemyList.ChkEnd())
      var enemy : @Enemy :: this.enemyList.Get() $ @Enemy
      if (enemy.state = @Enemy#State#Active | enemy.stateCount % 2 = 0)
        var x : float :: enemy.position.x - camera.x
        var y : float :: enemy.position.y - camera.y
        do enemy.animation.Draw(x, y)
      end if
      do this.enemyList.Next()
    end while
  end func
end class

func Create() : @EnemyList
  var enemyList : @EnemyList :: #@EnemyList
  do enemyList.Initialize()
  return enemyList
end func
